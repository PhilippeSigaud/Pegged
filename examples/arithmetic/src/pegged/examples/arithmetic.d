/**
This module contains a example of a reusable arithmetic expression grammar and
a recursive ParseTree parser that returns the evaluation of the arithmetic expression
*/
module pegged.examples.arithmetic;

import std.conv: to;

import pegged.grammar;

@safe:

mixin(grammar(`
# Arithmetic grammar with variable terminal
Arithmetic:
    Term     < Factor (Add / Sub)*
    Add      < "+" Factor
    Sub      < "-" Factor
    Factor   < Primary (Mul / Div)*
    Mul      < "*" Primary
    Div      < "/" Primary
    Primary  < Parens / Neg / Number / Variable
    Parens   < :"(" Term :")"
    Neg      < "-" Primary
    Number   < ~([0-9]+)
    Variable <- identifier
`));

mixin(grammar(`
# Arithmetic grammar without variable terminal
ArithmeticNoVar:
    Term     < Factor (Add / Sub)*
    Add      < "+" Factor
    Sub      < "-" Factor
    Factor   < Primary (Mul / Div)*
    Mul      < "*" Primary
    Div      < "/" Primary
    Primary  < Parens / Neg / Number
    Parens   < :"(" Term :")"
    Neg      < "-" Primary
    Number   < ~([0-9]+)
`));

/**
 * Parses a ParseTree as a arithmetic expression
 * @param T arithmetic type. By default is float.
 * @param grammarName Name of the arithmetic grammar. Must be "ArithmeticNoVar" or "Arithmetic". By default is "ArithmeticNoVar"
 * @param ParseTree p ParseTree generated by ArithmeticNoVar
 * @param variable Associative array with variable values
 * @return The result of the arithmetic expresion. If the ParseTree is invalid
 *  or contains unexpected nodes, then will return NaN if T is a float or 0
 *  if T is a integral
 */
T parseArithmetic(T = float, string grammarName = "ArithmeticNoVar")(const ParseTree p,
    const T[string] variables = null)
if (__traits(isArithmetic, T) && (grammarName == "ArithmeticNoVar" || grammarName == "Arithmetic"))
{
    switch (p.name)
    {
        case grammarName:
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Term":
            T val;
            static if (__traits(isFloating, T)) {
                val = 0.0; // float init is NaN
            }
            foreach(child; p.children) {
                val += parseArithmetic!(T, grammarName)(child, variables);
            }
            return val;
        case grammarName ~ ".Add":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Sub":
            return -parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Factor":
            import std.string : lastIndexOf;
            T val = to!T(1.0);
            foreach(child; p.children) {
                const childName = child.name[lastIndexOf(child.name, '.') + 1..$];
                if (childName == "Div") {
                    val /= parseArithmetic!(T, grammarName)(child, variables);
                } else { // Process Primary and Mul nodes
                    val *= parseArithmetic!(T, grammarName)(child, variables);
                }
            }
            return val;
        case grammarName ~ ".Mul":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Div":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Primary":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Parens":
            return parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Neg":
            return -parseArithmetic!(T, grammarName)(p.children[0], variables);
        case grammarName ~ ".Number":
            return to!T(p.matches[0]);
        case grammarName ~ ".Variable":
            return variables[p.matches[0]];
        default:
            return T.init;
    }
}

unittest
{   // Testing parsing arithmetic expression without variables
    string testExpression = "1 + 2 * (3 + 10 / 4)";
    const pNoVar = ArithmeticNoVar(testExpression);

    assert(pNoVar.successful);
    assert(pNoVar.toString == q"EOS
ArithmeticNoVar[0, 20]["1", "+", "2", "*", "3", "+", "10", "/", "4"]
 +-ArithmeticNoVar.Term[0, 20]["1", "+", "2", "*", "3", "+", "10", "/", "4"]
    +-ArithmeticNoVar.Factor[0, 2]["1"]
    |  +-ArithmeticNoVar.Primary[0, 2]["1"]
    |     +-ArithmeticNoVar.Number[0, 2]["1"]
    +-ArithmeticNoVar.Add[2, 20]["+", "2", "*", "3", "+", "10", "/", "4"]
       +-ArithmeticNoVar.Factor[4, 20]["2", "*", "3", "+", "10", "/", "4"]
          +-ArithmeticNoVar.Primary[4, 6]["2"]
          |  +-ArithmeticNoVar.Number[4, 6]["2"]
          +-ArithmeticNoVar.Mul[6, 20]["*", "3", "+", "10", "/", "4"]
             +-ArithmeticNoVar.Primary[8, 20]["3", "+", "10", "/", "4"]
                +-ArithmeticNoVar.Parens[8, 20]["3", "+", "10", "/", "4"]
                   +-ArithmeticNoVar.Term[9, 19]["3", "+", "10", "/", "4"]
                      +-ArithmeticNoVar.Factor[9, 11]["3"]
                      |  +-ArithmeticNoVar.Primary[9, 11]["3"]
                      |     +-ArithmeticNoVar.Number[9, 11]["3"]
                      +-ArithmeticNoVar.Add[11, 19]["+", "10", "/", "4"]
                         +-ArithmeticNoVar.Factor[13, 19]["10", "/", "4"]
                            +-ArithmeticNoVar.Primary[13, 16]["10"]
                            |  +-ArithmeticNoVar.Number[13, 16]["10"]
                            +-ArithmeticNoVar.Div[16, 19]["/", "4"]
                               +-ArithmeticNoVar.Primary[18, 19]["4"]
                                  +-ArithmeticNoVar.Number[18, 19]["4"]
EOS");

    // Parsing as a float
    const f = parseArithmetic(pNoVar);
    assert(f == 12.0f);

    // Parsing as integer
    const i = parseArithmetic!int(pNoVar);
    assert(i == 11);
}

unittest
{
    // Testing parsing arithmetic expression witht variables

    string testExpressionWithVar = "1 + 2 * (3 + 10 / 4) + fooBar";
    const p = Arithmetic(testExpressionWithVar);

    assert(p.successful);
    assert(p.toString == q"EOS
Arithmetic[0, 29]["1", "+", "2", "*", "3", "+", "10", "/", "4", "+", "fooBar"]
 +-Arithmetic.Term[0, 29]["1", "+", "2", "*", "3", "+", "10", "/", "4", "+", "fooBar"]
    +-Arithmetic.Factor[0, 2]["1"]
    |  +-Arithmetic.Primary[0, 2]["1"]
    |     +-Arithmetic.Number[0, 2]["1"]
    +-Arithmetic.Add[2, 21]["+", "2", "*", "3", "+", "10", "/", "4"]
    |  +-Arithmetic.Factor[4, 21]["2", "*", "3", "+", "10", "/", "4"]
    |     +-Arithmetic.Primary[4, 6]["2"]
    |     |  +-Arithmetic.Number[4, 6]["2"]
    |     +-Arithmetic.Mul[6, 21]["*", "3", "+", "10", "/", "4"]
    |        +-Arithmetic.Primary[8, 21]["3", "+", "10", "/", "4"]
    |           +-Arithmetic.Parens[8, 21]["3", "+", "10", "/", "4"]
    |              +-Arithmetic.Term[9, 19]["3", "+", "10", "/", "4"]
    |                 +-Arithmetic.Factor[9, 11]["3"]
    |                 |  +-Arithmetic.Primary[9, 11]["3"]
    |                 |     +-Arithmetic.Number[9, 11]["3"]
    |                 +-Arithmetic.Add[11, 19]["+", "10", "/", "4"]
    |                    +-Arithmetic.Factor[13, 19]["10", "/", "4"]
    |                       +-Arithmetic.Primary[13, 16]["10"]
    |                       |  +-Arithmetic.Number[13, 16]["10"]
    |                       +-Arithmetic.Div[16, 19]["/", "4"]
    |                          +-Arithmetic.Primary[18, 19]["4"]
    |                             +-Arithmetic.Number[18, 19]["4"]
    +-Arithmetic.Add[21, 29]["+", "fooBar"]
       +-Arithmetic.Factor[23, 29]["fooBar"]
          +-Arithmetic.Primary[23, 29]["fooBar"]
             +-Arithmetic.Variable[23, 29]["fooBar"]
EOS");

    // Parsing as a float
    const float[string] fVars = ["fooBar": 10.25f];
    const fWithVar = parseArithmetic!(float, "Arithmetic")(p, fVars );

    assert(fWithVar == 22.25f);

    // Parsing as integer
    const iVars = ["fooBar": 10];
    const iWithVar = parseArithmetic!(int, "Arithmetic")(p, iVars);

    assert(iWithVar == 21);
}


unittest
{
    // Some additional test borrowed from simple_arithmetic
    float interpreter(string expr) => ArithmeticNoVar(expr).parseArithmetic;

    assert(interpreter("1") == 1.0);
    assert(interpreter("-1") == -1.0);
    assert(interpreter("1+1") == 2.0);
    assert(interpreter("1-1") == 0.0);

    assert(interpreter("1+1+1") == 3.0);
    assert(interpreter("1-1-1") == -1.0);
    assert(interpreter("1+1-1") == 1.0);
    assert(interpreter("1-1+1") == 1.0);
    assert(interpreter("-1+1+1") == 1.0);

    assert(interpreter("(-1+1)+1") == 1.0);
    assert(interpreter("-1+(1+1)") == 1.0);
    assert(interpreter("(-1+1+1)") == 1.0);
    assert(interpreter("1-(1-1)") == 1.0);

    assert(interpreter("1*1") == 1.0);
    assert(interpreter("1/1") == 1.0);
    assert(interpreter("-1*1") == -1.0);
    assert(interpreter("-1/1") == -1.0);

    assert(interpreter("1+2*3") == 7.0);
    assert(interpreter("1-2*3") == -5.0);
    assert(interpreter("-1-2*-3") == 5.0);
    assert(interpreter("-1+2*-3") == -7.0);

    assert(interpreter("1/2/(1/2)") == 1.0);
    assert(interpreter("1/2/1/2") == .25);
    assert(interpreter("1 - 2*3 - 2*3") == -11.0);

    assert(interpreter("2*3*3 - 3*3 + 3*4") == 21.0);
    assert(interpreter("2 * 3 * 3 - 3 * (3 + 3 * 4)") == -27.0);
}
